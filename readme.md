# Catalog API microservice

## Добавление зависимостей
```bash
dotnet add package "Carter" --version "9.0.0" 
dotnet add package "Marten" --version "7.39.3" 
dotnet add package "Mapster" --version "7.4.0" 
dotnet add package "FluentValidation" --version "11.11.0" 
dotnet add package "FluentValidation.AspNetCore" --version "11.3.0" 
dotnet add package "FluentValidation.DependencyInjectionExtensions" --version "11.11.0" 
dotnet add package "MediatR" --version "12.4.1" 
```

## CQRS (Command Query Responsibility Segregation)

CQRS — это архитектурный паттерн, который разделяет ответственность за обработку команд (изменений состояния) и выполнение запросов (чтения данных). Этот подход часто используется в системах, где важно эффективно управлять сложной бизнес-логикой и обеспечивать высокую производительность.

### Основная идея CQRS

#### Команды (Commands):
- Отвечают за изменение состояния системы
- Например, создание топика или добавление комментария в социальной сети
- Команды обрабатываются через доменные модели, такие как агрегаты, которые обеспечивают соблюдение бизнес-правил

#### Запросы (Queries):
- Отвечают за чтение данных
- Например, получение списка топиков содержащих комментарии для отображения пользователю
- Запросы обычно работают с оптимизированными для чтения моделями данных, которые могут отличаться от моделей, используемых для команд

### Зачем нужен CQRS?

1. **Разделение ответственности:**
   - Разделение чтения и записи упрощает код и делает его более понятным. Логика изменения состояния сосредоточена в одной части системы, а логика чтения — в другой

2. **Оптимизация производительности:**
   - Для запросов можно использовать специализированные модели данных (например, денормализованные таблицы или кэши), что ускоряет операции чтения без влияния на операции записи

3. **Масштабируемость:**
   - Чтение и запись можно масштабировать независимо друг от друга. Например, если система испытывает большую нагрузку на запросы (чтение), можно оптимизировать только эту часть

4. **Упрощение сложной логики:**
   - В системах с насыщенной бизнес-логикой CQRS помогает изолировать изменения состояния от операций чтения, что снижает вероятность ошибок и упрощает тестирование

### Разделённый код с CQRS

После применения CQRS методы для чтения данных (запросы) и изменения состояния (команды) разделяются на разные классы или слои.

#### Команды (Commands)

Команды представляют намерение изменить состояние системы.

#### Запросы (Queries)

Запросы отвечают за получение данных без изменения состояния

## Про проектирование

## 1. Проектирование на основе данных (Data-Driven Design)

Этот подход фокусируется на структуре данных и их взаимосвязях. Микросервисы проектируются вокруг определенных сущностей или групп данных.

## 2. Проектирование на основе предметной области (Domain-Driven Design)

DDD - это более комплексный подход, который учитывает не только структуру данных, но и бизнес-логику, процессы и ограниченные контексты.

## 3. Проектирование на основе команд (Command Query Responsibility Segregation, CQRS)

CQRS разделяет операции чтения и записи в отдельные модели, что может привести к созданию отдельных микросервисов для команд и запросов.

## 4. Проектирование на основе событий (Event-Driven Architecture)

В этом подходе микросервисы проектируются вокруг событий, которые происходят в системе, и их обработки.

## 5. Проектирование на основе бизнес-возможностей

Этот метод фокусируется на выделении микросервисов в соответствии с бизнес-функциями или возможностями организации.

## 6. Проектирование на основе подзадач (Decomposition by Subdomain)

Здесь система разбивается на подобласти, каждая из которых становится отдельным микросервисом.


## Основные отличия Data-Driven Design от Domain-Driven Design можно свести к:

### 1. Исходная точка проектирования
| **Data-Driven** | **Domain-Driven** |
|------------------|--------------------|
| Начинается с проектирования структуры БД и таблиц | Фокусируется на моделировании бизнес-процессов и правил |
| Пример: Создание сущностей через ORM по схеме БД | Пример: Выделение агрегатов с инкапсулированной бизнес-логикой |

### 2. Работа с бизнес-логикой
- **Data-Driven**: Логика выносится в отдельные сервисы, приводит к "анаемичным моделям" (Anemic Domain Model)
- **Domain-Driven**: Бизнес-правила встроены в доменные объекты через методы (например, `Order.AddItem()` с проверкой доступности товара)

### 3. Масштабируемость и сложность
- **Data-Driven**:
  - Быстрый старт для простых CRUD-приложений
  - Проблемы с согласованностью данных на крупных проектах
- **Domain-Driven**:
  - Эффективен для сложных систем с богатой логикой
  - Требует значительных ресурсов на этапе проектирования

### 4. Организация архитектуры
| Критерий          | Data-Driven       | Domain-Driven     |
|-----------------|-------------------|-------------------|
| Границы модулей | По структуре данных | По ограниченным контекстам (Bounded Contexts) |
| Интеграция      | Общие таблицы БД | События и API-шлюзы |

### 5. Процесс разработки
- **Data-Driven**:
  - Минимизация взаимодействия с бизнес-экспертами
  - Кодогенерация по схеме данных
- **Domain-Driven**:
  - Совместная разработка с заказчиком (разговариваем на его языке)
  - Использование артефактов, напрямую выявленных в процессе описания бизнес-процессов

**Замечание**: Оба подхода могут комбинироваться — Domain-Driven для ядра системы, Data-Driven — для вспомогательных модулей.

## Инструкция для подключения БД

### Создания контейнера с базой данных

```bash
docker run --name catalog-db \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=12345678 \
  -e POSTGRES_DB=catalog-db \
  -p 15001:5432 \
  -d postgres
```

### Строка подключения

```json
"ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Port=5101;Database=catalog-db;User Id=postgres;Password=12345678;Include Error Detail=true"
}
```